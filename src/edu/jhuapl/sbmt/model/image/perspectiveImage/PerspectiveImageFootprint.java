package edu.jhuapl.sbmt.model.image.perspectiveImage;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

import vtk.vtkActor;
import vtk.vtkFeatureEdges;
import vtk.vtkFloatArray;
import vtk.vtkPointData;
import vtk.vtkPolyData;
import vtk.vtkPolyDataMapper;
import vtk.vtkPolyDataReader;
import vtk.vtkPolyDataWriter;
import vtk.vtkProp;
import vtk.vtkProperty;
import vtk.vtkTexture;
import vtk.vtkXMLPolyDataReader;

import edu.jhuapl.saavtk.util.FileCache;
import edu.jhuapl.saavtk.util.PolyDataUtil;
import edu.jhuapl.saavtk.util.Properties;
import edu.jhuapl.sbmt.model.image.ImageKeyInterface;
import edu.jhuapl.sbmt.model.image.ImageSource;

public class PerspectiveImageFootprint
{
	vtkPolyData[] footprint = new vtkPolyData[1];
	boolean[] footprintGenerated = new boolean[1];
	final vtkPolyData[] shiftedFootprint = new vtkPolyData[1];
	private vtkActor footprintActor;
	private List<vtkProp> footprintActors = new ArrayList<vtkProp>();
	private boolean useDefaultFootprint = true;
	int nslices;
	PerspectiveImage image;
    // If true, then the footprint is generated by intersecting a frustum with the
    // asteroid.
    // This setting is used when generating the files on the server.
    // If false, then the footprint is downloaded from the server. This setting is
    // used by the GUI.
    private static boolean generateFootprint = true;
    private vtkFloatArray textureCoords;
    private double imageOpacity = 1.0;
    protected vtkTexture imageTexture;
    private vtkPolyData boundary;

	PerspectiveImageFootprint(PerspectiveImage image)
	{
		this.image = image;
		nslices = image.getImageDepth();
		footprint = new vtkPolyData[nslices];
		footprint[0] = new vtkPolyData();
		footprintGenerated = new boolean[nslices];
		shiftedFootprint[0] = new vtkPolyData();

	}

	public void initialize()
	{

	}

	public void initSpacecraftStateVariables()
	{
		footprint = new vtkPolyData[nslices];
        footprintGenerated = new boolean[nslices];
	}

	public void updatePointing(PerspectiveImage image)
	{
//		this.scPos = image.getSpacecraftPositionAdjusted();
//		this.frus1 = image.getFrustum1Adjusted();
//		this.frus2 = image.getFrustum2Adjusted();
//		this.frus3 = image.getFrustum3Adjusted();
//		this.frus4 = image.getFrustum4Adjusted();
	}

	public boolean[] getFootprintGenerated()
	{
		return footprintGenerated;
	}

	public void setFootprintGenerated(boolean footprintGenerated)
	{
		this.footprintGenerated[image.getDefaultSlice()] = footprintGenerated;
	}

	public void setFootprintGenerated(boolean footprintGenerated, int slice)
	{
		this.footprintGenerated[slice] = footprintGenerated;
	}

	public static boolean isGenerateFootprint()
	{
		return generateFootprint;
	}

	/**
	 * The shifted footprint is the original footprint shifted slightly in the
	 * normal direction so that it will be rendered correctly and not obscured
	 * by the asteroid.
	 *
	 * @return
	 */
	vtkPolyData getShiftedFootprint()
	{
		return shiftedFootprint[0];
	}

	/**
	 * The original footprint whose cells exactly overlap the original asteroid.
	 * If rendered as is, it would interfere with the asteroid. Note: this is
	 * made public in this class for the benefit of backplane generators, which
	 * use it.
	 *
	 * @return
	 */
	vtkPolyData getUnshiftedFootprint()
	{
		return footprint[image.currentSlice];
	}

	vtkPolyData generateBoundary()
	{
		loadFootprint();

		if (footprint[image.currentSlice].GetNumberOfPoints() == 0)
			return null;

		vtkFeatureEdges edgeExtracter = new vtkFeatureEdges();
		edgeExtracter.SetInputData(footprint[image.currentSlice]);
		edgeExtracter.BoundaryEdgesOn();
		edgeExtracter.FeatureEdgesOff();
		edgeExtracter.NonManifoldEdgesOff();
		edgeExtracter.ManifoldEdgesOff();
		edgeExtracter.ColoringOff();
		edgeExtracter.Update();

		boundary = new vtkPolyData();
		vtkPolyData edgeExtracterOutput = edgeExtracter.GetOutput();
		boundary.DeepCopy(edgeExtracterOutput);

		return boundary;
	}

	public void loadFootprint()
    {
    	int currentSlice = image.currentSlice;
    	double[][] spacecraftPositionAdjusted = image.getSpacecraftPositionAdjusted();
    	double[][] frustum1Adjusted = image.getFrustum1Adjusted();
    	double[][] frustum2Adjusted = image.getFrustum2Adjusted();
    	double[][] frustum3Adjusted = image.getFrustum3Adjusted();
    	double[][] frustum4Adjusted = image.getFrustum4Adjusted();
        vtkPolyData existingFootprint = checkForExistingFootprint();
        if (existingFootprint != null)
        {
//        	System.out.println("PerspectiveImage: loadFootprint: existing footprint");
            footprint[0] = existingFootprint;

            vtkPointData pointData = footprint[currentSlice].GetPointData();
            pointData.SetTCoords(textureCoords);
//            System.out.println("PerspectiveImage: loadFootprint: setting texture coords " + sw.elapsedMillis());
            PolyDataUtil.generateTextureCoordinates(image.getFrustum(), image.getImageWidth(), image.getImageHeight(), footprint[currentSlice]);
//            System.out.println("PerspectiveImage: loadFootprint: set texture coords " + sw.elapsedMillis());
            pointData.Delete();

            shiftedFootprint[0].DeepCopy(footprint[currentSlice]);
            PolyDataUtil.shiftPolyDataInNormalDirection(shiftedFootprint[0], image.getOffset());
            return;
        }

        if (generateFootprint)
        {
//        	System.out.println("PerspectiveImage: loadFootprint: generate footprint true");
            vtkPolyData tmp = null;

            if (!footprintGenerated[currentSlice])
            {
//            	System.out.println("PerspectiveImage: loadFootprint: footprint not generated");
                if (useDefaultFootprint())
                {
//                	System.out.println("PerspectiveImage: loadFootprint: using default footprint");
                    int defaultSlice = image.getDefaultSlice();
                    if (footprintGenerated[defaultSlice] == false)
                    {
                        footprint[defaultSlice] = getFootprint(defaultSlice);
                        if (footprint[defaultSlice] == null)
                            return;

                        // Need to clear out scalar data since if coloring data is being shown,
                        // then the color might mix-in with the image.
                        footprint[defaultSlice].GetCellData().SetScalars(null);
                        footprint[defaultSlice].GetPointData().SetScalars(null);

                        footprintGenerated[defaultSlice] = true;
                    }

                    tmp = footprint[defaultSlice];

                }
                else
                {
//                	System.out.println("PerspectiveImage: loadFootprint: computing new intersection");
                    tmp = image.getSmallBodyModel().computeFrustumIntersection(spacecraftPositionAdjusted[currentSlice], frustum1Adjusted[currentSlice], frustum3Adjusted[currentSlice], frustum4Adjusted[currentSlice], frustum2Adjusted[currentSlice]);
                    if (tmp == null)
                        return;

                    // Need to clear out scalar data since if coloring data is being shown,
                    // then the color might mix-in with the image.
                    tmp.GetCellData().SetScalars(null);
                    tmp.GetPointData().SetScalars(null);
                }

                // vtkPolyDataWriter writer=new vtkPolyDataWriter();
                // writer.SetInputData(tmp);
                // writer.SetFileName("/Users/zimmemi1/Desktop/test.vtk");
                // writer.SetFileTypeToBinary();
                // writer.Write();

                footprint[currentSlice].DeepCopy(tmp);

                footprintGenerated[currentSlice] = true;
            }
//            System.out.println("PerspectiveImage: loadFootprint: footprint generated");
            vtkPointData pointData = footprint[currentSlice].GetPointData();
            pointData.SetTCoords(textureCoords);
            PolyDataUtil.generateTextureCoordinates(image.getFrustum(), image.getImageWidth(), image.getImageHeight(), footprint[currentSlice]);
            pointData.Delete();
        }
        else
        {
        	ImageKeyInterface key = image.getKey();
//        	System.out.println("PerspectiveImage: loadFootprint: fetching from server, generate footprint false");
            int resolutionLevel = image.getSmallBodyModel().getModelResolution();

            String footprintFilename = null;
            File file = null;

            if (key.getSource() == ImageSource.SPICE || key.getSource() == ImageSource.CORRECTED_SPICE)
                footprintFilename = key.getName() + "_FOOTPRINT_RES" + resolutionLevel + "_PDS.VTP";
            else
                footprintFilename = key.getName() + "_FOOTPRINT_RES" + resolutionLevel + "_GASKELL.VTP";

            file = FileCache.getFileFromServer(footprintFilename);

            if (file == null || !file.exists())
            {
                System.out.println("Warning: " + footprintFilename + " not found");
                return;
            }

            vtkXMLPolyDataReader footprintReader = new vtkXMLPolyDataReader();
            footprintReader.SetFileName(file.getAbsolutePath());
            footprintReader.Update();

            vtkPolyData footprintReaderOutput = footprintReader.GetOutput();
            footprint[currentSlice].DeepCopy(footprintReaderOutput);
        }

        shiftedFootprint[0].DeepCopy(footprint[currentSlice]);
        PolyDataUtil.shiftPolyDataInNormalDirection(shiftedFootprint[0], image.getOffset());
        vtkPolyDataWriter writer = new vtkPolyDataWriter();
        writer.SetInputData(footprint[0]);
//        System.out.println("PerspectiveImage: loadFootprint: fit file full path " + getFitFileFullPath());
        String intersectionFileName = image.getPrerenderingFileNameBase() + "_frustumIntersection.vtk";
        File file = FileCache.instance().getFile(intersectionFileName);
//        System.out.println("PerspectiveImage: loadFootprint: saving to " + intersectionFileName);
        writer.SetFileName(file.getPath());
        writer.SetFileTypeToBinary();
        writer.Write();
        setFootprintGenerated(true);
    }



	public vtkPolyData getFootprint(int defaultSlice)
    {
        if (footprint[0] != null && footprint[0].GetNumberOfPoints() > 0)
            return footprint[0];
        // first check the cache
        vtkPolyData existingFootprint = checkForExistingFootprint();
        if (existingFootprint != null)
        {
            return existingFootprint;
        }
        else
        {
            vtkPolyData footprint = image.getSmallBodyModel().computeFrustumIntersection(image.getSpacecraftPositionAdjusted()[defaultSlice], image.getFrustum1Adjusted()[defaultSlice], image.getFrustum3Adjusted()[defaultSlice], image.getFrustum4Adjusted()[defaultSlice], image.getFrustum2Adjusted()[defaultSlice]);
            return footprint;
        }
    }

    vtkPolyData checkForExistingFootprint()
    {
    	if (getFootprintGenerated()[image.getCurrentSlice()] == false) return null;
        String intersectionFileName = image.getPrerenderingFileNameBase() + "_frustumIntersection.vtk.gz";
        if (FileCache.isFileGettable(intersectionFileName))
        {
            File file = FileCache.getFileFromServer(intersectionFileName);
            vtkPolyDataReader reader = new vtkPolyDataReader();
//            reader.SetFileName(file.getPath().replaceFirst("\\.[^\\.]*$", ""));	//This is wrong.  The old code was stripping off .gz from the intersection name.  This now further removes .vtk which is bad.
            reader.SetFileName(file.getAbsolutePath()); // now just reads in the file path as it should.
            reader.Update();
            vtkPolyData footprint = reader.GetOutput();
            return footprint;
        }
        return null;
    }

    public vtkPolyData[] getFootprint()
	{
		return footprint;
	}

	public void setFootprint(vtkPolyData[] footprint)
	{
		this.footprint = footprint;
	}

    static void setGenerateFootprint(boolean b)
    {
        generateFootprint = b;
    }

	void setUseDefaultFootprint(boolean useDefaultFootprint)
	{
		this.useDefaultFootprint = useDefaultFootprint;
		for (int i = 0; i < image.getImageDepth(); i++)
		{
			footprintGenerated[i] = false;
		}
	}

	boolean useDefaultFootprint()
	{
		return useDefaultFootprint;
	}

	void Delete()
	{
		for (int i = 0; i < footprint.length; i++)
        {
            // Footprints can be null if no frustum intersection is found
            if (footprint[i] != null)
            {
                footprint[i].Delete();
            }
        }

        for (int i = 0; i < shiftedFootprint.length; i++)
        {
            if (shiftedFootprint[i] != null)
            {
                shiftedFootprint[i].Delete();
            }
        }
        textureCoords.Delete();
	}

	List<vtkProp> getProps()
	{
		if (footprintActor == null)
        {
            loadFootprint();

            imageTexture = new vtkTexture();
            imageTexture.InterpolateOn();
            imageTexture.RepeatOff();
            imageTexture.EdgeClampOn();
            imageTexture.SetInputData(image.getDisplayedImage());
			vtkPolyDataMapper footprintMapper = new vtkPolyDataMapper();
	        footprintMapper.SetInputData(shiftedFootprint[0]);
	        footprintMapper.Update();
	        footprintActor = new vtkActor();
	        footprintActor.SetMapper(footprintMapper);
	        footprintActor.SetTexture(imageTexture);
	        vtkProperty footprintProperty = footprintActor.GetProperty();
	        footprintProperty.LightingOff();

	        if (boundary == null) generateBoundary();
	        vtkActor boundaryActor = new vtkActor();
	        vtkPolyDataMapper boundaryMapper = new vtkPolyDataMapper();
	        boundaryMapper.SetInputData(boundary);
	        boundaryMapper.Update();
	        boundaryActor.SetMapper(boundaryMapper);
	        boundaryActor.GetProperty().SetColor(new double[] {0.0, 1.0, 0.0});
	        boundaryActor.GetProperty().SetLineWidth(3.0);
	        footprintActors.add(boundaryActor);


	        footprintActors.add(footprintActor);
        }
	    return footprintActors;
	}

	void initializeMaskingAfterLoad()
    {
		for (int k = 0; k < image.getImageDepth(); k++)
        {
            footprint[k] = new vtkPolyData();
        }

        shiftedFootprint[0] = new vtkPolyData();
        textureCoords = new vtkFloatArray();
    }

	public void setOpacity(double imageOpacity)
    {
        this.imageOpacity = imageOpacity;
        vtkProperty smallBodyProperty = footprintActor.GetProperty();
        smallBodyProperty.SetOpacity(imageOpacity);
        image.firePropertyChange(Properties.MODEL_CHANGED, null, this);
    }

    public double getOpacity()
    {
        return imageOpacity;
    }

    public void setVisible(boolean b)
    {
        footprintActor.SetVisibility(b ? 1 : 0);
    }

    vtkTexture getTexture()
    {
        return imageTexture;
    }

	public vtkActor getFootprintActor()
	{
		return footprintActor;
	}

}
